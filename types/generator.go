// Copyright 2023 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//go:build ignore

// This file implements a custom generator to create various go/types
// source files from the corresponding types2 files.

package main

import (
	"bytes"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"log"
	"os"
	"path/filepath"
	"runtime"
	"strings"
)

const (
	srcDir = "cmd/compile/internal/types2"
	dstDir = "go/types"
)

var fset = token.NewFileSet()

func main() {
	for filename, action := range filemap {
		// parse src
		srcFilename := filepath.FromSlash(runtime.GOROOT() + "/src/" + srcDir + "/" + filename)
		file, err := parser.ParseFile(fset, srcFilename, nil, parser.ParseComments)
		if err != nil {
			log.Fatal(err)
		}

		// fix package name
		file.Name.Name = strings.ReplaceAll(file.Name.Name, "types2", "types")

		// rewrite AST as needed
		if action != nil {
			action(file)
		}

		// format AST
		var buf bytes.Buffer
		buf.WriteString("// Code generated by \"go run generator.go\"; DO NOT EDIT.\n\n")
		if err := format.Node(&buf, fset, file); err != nil {
			log.Fatal(err)
		}

		// write dst
		dstFilename := filepath.FromSlash(runtime.GOROOT() + "/src/" + dstDir + "/" + filename)
		if err := os.WriteFile(dstFilename, buf.Bytes(), 0o644); err != nil {
			log.Fatal(err)
		}
	}
}

type action func(in *ast.File)

var filemap = map[string]action{
	"chan.go":          nil,
	"context.go":       nil,
	"gccgosizes.go":    nil,
	"lookup.go":        nil,
	"main_test.go":     nil,
	"map.go":           nil,
	"named.go":         func(f *ast.File) { fixTokenPos(f); fixTraceSel(f) },
	"objset.go":        nil,
	"pointer.go":       nil,
	"selection.go":     nil,
	"sizes.go":         func(f *ast.File) { rename(f, "IsSyncAtomicAlign64", "isSyncAtomicAlign64") },
	"slice.go":         nil,
	"subst.go":         func(f *ast.File) { fixTokenPos(f); fixTraceSel(f) },
	"termlist.go":      nil,
	"termlist_test.go": nil,
	"tuple.go":         nil,
	"typelists.go":     nil,
	"typeparam.go":     nil,
	"typeterm.go":      nil,
	"validtype.go":     nil,
}

// TODO(gri) We should be able to make these rewriters more configurable/composable.
//           For now this is a good starting point.

func rename(f *ast.File, from, to string) {
	ast.Inspect(f, func(n ast.Node) bool {
		switch n := n.(type) {
		case *ast.Ident:
			if n.Name == from {
				n.Name = to
			}
			return false
		}
		return true
	})
}

func fixTokenPos(f *ast.File) {
	ast.Inspect(f, func(n ast.Node) bool {
		switch n := n.(type) {
		case *ast.ImportSpec:
			if n.Path.Kind == token.STRING && n.Path.Value == `"cmd/compile/internal/syntax"` {
				n.Path.Value = `"go/token"`
				return false
			}
		case *ast.SelectorExpr:
			if x, _ := n.X.(*ast.Ident); x != nil && x.Name == "syntax" && n.Sel.Name == "Pos" {
				x.Name = "token"
				return false
			}
		}
		return true
	})
}

func fixTraceSel(f *ast.File) {
	ast.Inspect(f, func(n ast.Node) bool {
		switch n := n.(type) {
		case *ast.SelectorExpr:
			if n.Sel.Name == "Trace" {
				n.Sel.Name = "trace"
				return false
			}
		}
		return true
	})
}
